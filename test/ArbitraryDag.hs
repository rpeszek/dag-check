{-
Arbitrary Simple Directed Acyclic graph that has positive likelihood to generate 
every possible DAG topology
-}

{-# LANGUAGE 
   MultiParamTypeClasses
  , ScopedTypeVariables
  , FlexibleInstances
  , GeneralizedNewtypeDeriving 
#-}

module ArbitraryDag where
import Test.QuickCheck
import Data.List
import System.Random (Random)
import Control.Monad (replicateM, mapM)
import Data.Maybe (catMaybes)
import Data.Bool (bool)

{- Helper data types used for Arbitrary generation -}
type GenSingleEdge v e = v -> v -> Gen e
type TopSortedVs v = [v]

{-| Represents general directed graph -}
data SampleDirGraph v e = SampleDirGraph {
   sortedVerts :: TopSortedVs v
  , edges :: [e]
} deriving Show

empty :: SampleDirGraph v e 
empty = SampleDirGraph [] []

singleton ::  v -> SampleDirGraph v e
singleton vx = SampleDirGraph [vx] [] 

disconnected ::  [v] -> SampleDirGraph v e
disconnected vx = SampleDirGraph vx [] 

{-| Represents randomly generated Simple DAG -}
data ArbitrarySimpleDag v e = ArbitrarySimpleDag (SampleDirGraph v e) deriving Show

{- Convience types (Seqential is defined below)-}
type SimpleSequentialDag = ArbitrarySimpleDag Seqential (Seqential, Seqential)    
type SimpleIntDag = ArbitrarySimpleDag Int (Int, Int)

instance (GenSimpleEdges v e, GenVertices v, Eq e) => Arbitrary (ArbitrarySimpleDag v e) where
    arbitrary = genSimpleDag


{- DAGs are generated by implementing 2 interfaces GenVertices and GenSimpleEdges -}

{-| First interface needed for DAG generation -}
class GenVertices a where
  genVertices :: Int -> Gen [a]

instance GenVertices Int where
  genVertices = vector

{-| Second interface needed for DAG generation -}
class GenSimpleEdges v e where
   genEdges :: TopSortedVs v -> Gen [e]

instance GenSimpleEdges Int (Int, Int) where
  genEdges = (genEdgesM1 genEdgeForPair)


genEdgeForPair :: GenSingleEdge v (v,v)
genEdgeForPair v1 v2 = return (v1, v2)

{-| For default impementation of GenSimpleEdges -}

{- method 1 generates DAG by removing some edges from complete DAG -}
genEdgesM1 :: (GenVertices v, Eq e) => GenSingleEdge v e -> TopSortedVs v -> Gen [e]
genEdgesM1 genEdge vertices = do 
   completeEdges <- completeSimpleDag genEdge vertices
   sublistOf completeEdges

{- all possible forward edges are created -}
completeSimpleDag :: GenSingleEdge v e -> TopSortedVs v -> Gen [e]
completeSimpleDag genEdge vertices = 
             let edgeIndecies =
                        [(i1, i2) | 
                                 i1 <- [0..(length vertices - 2)], 
                                 i2 <- [i1..(length vertices - 1)] 
                        ]
                  
                 addEdge (i1, i2) = 
                     genEdge (vertices !! i1) (vertices !! i2)
             in mapM addEdge edgeIndecies
                

{- method 2 generates DAG by adding some edges to empty DAG -}
genEdgesM2 :: forall v e. Eq e => GenSingleEdge v e -> TopSortedVs v -> Gen [e]
genEdgesM2 genEdge vertices = 
      let vcount = length vertices
          eCountMax = (vcount - 1) * vcount `quot` 2 --max possible number of edges in simple dag             
          -- defines a (possibly redunant) edge for topologically sorted vertices [v]
          newEdge :: [v] -> Gen (Maybe e)
          newEdge vertices = case length vertices of
           n
            | n < 2 -> return Nothing
            | n == 2 -> arbitrary >>= bool (return Nothing) (Just <$> genEdge (vertices !! 0) (vertices !! 1)) 
            | otherwise -> do
               inx <- choose (0, length vertices - 2) -- skip last element to give it room for a potential edge
               to <- elements $ drop (inx + 1) vertices
               fmap Just $ genEdge (vertices !! inx) to
      in fmap (catMaybes . nub) . replicateM eCountMax $ newEdge vertices


{- Helper / alternative methods for DAG generation -}
genSimpleDag :: (GenSimpleEdges v e, GenVertices v, Eq e) => Gen (ArbitrarySimpleDag v e)
genSimpleDag = arbitrarySizedNatural >>= genSizedSimpleDag

genSizedSimpleDag :: (GenSimpleEdges v e, GenVertices v, Eq e) => Int -> Gen (ArbitrarySimpleDag v e)
genSizedSimpleDag vcount = do
  case vcount of
     0 -> return $ ArbitrarySimpleDag empty
     1 -> fmap (ArbitrarySimpleDag . disconnected) (genVertices 1)  
     n -> 
        do 
          vertices <- genVertices vcount
          edges <- genEdges vertices
          return $ ArbitrarySimpleDag $ SampleDirGraph vertices edges

    
{-| Seqential type used for DAGs that are nicely sorted -}
newtype Seqential = Seqential Int deriving (Num, Eq, Ord)

instance Show Seqential where
  show (Seqential i) = show i

instance Arbitrary Seqential where
   arbitrary = Seqential . abs <$> (arbitrary :: Gen Int)

instance GenVertices Seqential where
  genVertices size = return $ map Seqential [0..size]

instance GenSimpleEdges Seqential (Seqential, Seqential) where
  genEdges = fmap sort . (genEdgesM2 genEdgeForPair)


{- test methods -}
test :: IO (SimpleIntDag)
test = generate arbitrary
-- 
testP :: IO (SimpleSequentialDag)
testP = generate arbitrary


{- Other: mapping between vertices and edges -}
class DiEdge v e where
  resolveEdge :: e -> (v,v)

instance DiEdge a (a,a) where
  resolveEdge = id
